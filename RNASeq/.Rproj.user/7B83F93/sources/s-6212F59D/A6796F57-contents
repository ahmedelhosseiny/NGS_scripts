# INTRODUCTION ------------------------------------------------------------
# I will try to provide the complete PDC-pipeline consisting of PROGENy, Dorothea
# and CARNIVAL based on these tutorials:
# https://www.bioconductor.org/packages/release/bioc/vignettes/progeny/inst/doc/progenyBulk.html
# https://github.com/saezlab/transcriptutorial
# https://github.com/saezlab/NetworkModeling_course_2020
# For now this pipeline will be adapted to work with DESeq2 results. It should require
# reasonable effort to make this work with sleuth or limma results.
# We will be going through the tools one by one and save data that we might need later on. 
# PROGENy output is optional for CARNIVAL so it may be left out.

# SET-UP ------------------------------------------------------------------
# rm(list = ls())

# We also want to have a certain directory structure to store output and saved
# data objects. For me this is 1. data - 1.1 output; 1.2 RDS Show warnings is 
# disabled so that we are not bothered if the directories already exist.
dir.create("data", showWarnings = FALSE)
dir.create("data/output", showWarnings = FALSE)
dir.create("data/RDS", showWarnings = FALSE)
dir.create("data/RAW", showWarnings = FALSE)

# Initialize variables for later use.
# This is a nice color palette.
cols <- cols <- pals::tableau20(20); scales::show_col(cols)
# Create a variable to our working directory for CARNIVAL - Cplex output
WORKDIR <- getwd()
# Prepare a list to collect our results.
myres_list <- list()

# We will need these libraries. Check out 'install.packages.R' if you want
# some help with the installation.
library(progeny)
library(dorothea)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(pheatmap)
library(readr)
library(DESeq2)
library(limma)
library(CARNIVAL)
library(tidyverse)
library(ggplot2)
library(fgsea)
library(dnet)
library(igraph)
library(limma)
library(patchwork)
library(ComplexHeatmap)

# FUNCTIONS ---------------------------------------------------------------
# Helpful functions to make plots look nicer and facilitate neat code.

## 'quantile_breaks' optimizes color range for heatmap plotting.
#'@param xs, vector of values to adjust palette breaks to
#'@param n, number of steps in color palette
quantile_breaks <- function(xs, n = 10) {
  breaks <- quantile(xs, probs = seq(0, 1, length.out = n))
  breaks[!duplicated(breaks)]
}

## 'networkCARNIVAL' constructs a network object out of CARNIVALs output
#'@param input.obj, unformatted CARNIVAL output
#'@param weightCut, threshold to dismiss edges with low weight
#'@param clusterSize, only allow clusters of given size in resulting graph
networkCARNIVAL <- function(input.obj, weightCut=0, clusterSize=2) {
  
  cRamp <- colorRampPalette(c("#1F77B4", "whitesmoke","#D62728"))(10)  
  
  C.net <- input.obj$weightedSIF %>%
    # transform to data.frame
    as.data.frame() %>%
    # make Node1 and Node2 the first columns of the data.frame
    dplyr::relocate(Node1) %>%
    dplyr::relocate(Node2, .after = Node1) %>%
    # transform Weight attribute to numeric and apply cutoff to remove unwanted edges
    dplyr::mutate( Weight = as.numeric(Weight) ) %>% 
    dplyr::filter( Weight >= weightCut ) %>%
    # edge colors - light blue: activation & light red: inhibition
    dplyr::mutate( edge.color = ifelse(Sign == 1, "#AEC7E8", ifelse(Sign == -1, "#FF9896","#C7C7C7"))) %>%
    dplyr::mutate( edge.label = ifelse(Sign == 1, "activation", ifelse(Sign == -1, "inhibition","connection"))) %>%
    dplyr::mutate( edge.type = ifelse(Weight >= 50, "solid", "dotted")) %>%
    #dplyr::mutate( edge.width = as.numeric(cut(Weight, breaks=c(0,25,50,75,100))))
    dplyr::mutate( edge.width = log(Weight, 5))
  

  nodes <- input.obj$nodesAttributes %>% 
    as.data.frame() %>% 
    dplyr::mutate(act_sign = sign(as.numeric(AvgAct))) %>%
    dplyr::mutate(AvgAct = as.double(AvgAct)) %>%
    #dplyr::filter(as.numeric(ZeroAct) != 100) %>%
    dplyr::mutate(NodeType = ifelse(nchar(NodeType)==0, "Protein",ifelse(NodeType == "T","TF","Perturbed"))) %>%
    dplyr::mutate( node.title = paste0(Node,"\n","Up activity: ",UpAct,"\n", "Down activity: ",DownAct,sep="")) %>%
    dplyr::mutate( node.color = cRamp[cut(AvgAct,breaks = 10)]) %>%
    dplyr::mutate( node.shape = ifelse(NodeType == "TF", "circle", ifelse(NodeType == "Perturbed", "square", "sphere")))
  
  ## this is tricky .. so its separate 
  # find all the nodes that ARE TARGETED by perturbed nodes (S)
  target.by.perturbed <- unique(C.net$Node2[which(C.net$Node1 %in% unique(nodes$Node[which(nodes$NodeType=="Perturbed")]))])
  # find all the nodes that TARGET TFs (T)
  target.tfs <- unique(C.net$Node1[which(C.net$Node2 %in% unique(nodes$Node[which(nodes$NodeType=="TF")]))])
  # And then apply
  nodes$node.level <- 3
  nodes$node.level[which(nodes$Node %in% target.by.perturbed)] = 2
  nodes$node.level[which(nodes$Node %in% target.tfs)] = 4
  nodes$node.level[which(nodes$NodeType=="Perturbed")] = 1
  nodes$node.level[which(nodes$NodeType=="TF")] = 5
  nodes$node.level[which(nodes$NodeType=="Pathway")] = 6 # i don't get this .. fix later maybe
  
  # this produces a network of all the nodes in the CARNIVAL output
  # so afterwards we will need to filter in some way
  C.net <- C.net %>%
    igraph::graph_from_data_frame(directed = TRUE, vertices = nodes)  
  
  
  deg <- degree(C.net, mode="all")
  V(C.net)$size <- as.numeric(factor(deg))
  
  # get component statistics and create subgraph that only contains connected nodes
  tmp <- igraph::components(C.net)
  tmp_clusters <- which(tmp$csize >= clusterSize)
  C.net <- igraph::induced_subgraph(C.net, names(tmp$membership[which(tmp$membership %in% tmp_clusters)]))
  
  return(C.net)
}


## 'plotCnet' visualizes the given graph using 'visNet' 
#'@param graph.obj, needs to be output of 'networkCARNIVAL' to ensure all parameters are set.
#'@param layoutType, 1:Fruchtermann-Reingold, 2:GraphOpt, 3:Circle, 4:Sphere, 5:Hierarchy
#'@param f.title, title of output generated in workdir, can also be full or relative path.
#'@param draw.legend, default TRUE
#'@param draw.description, default TRUE
#'@ToDo Hierarchy layout needs some work
plotCnet <- function(graph.obj, layoutType=1, f.title="CTF",draw.legend=TRUE, draw.description=TRUE) {
  # switch between different preset layouts
  l <- switch(layoutType,
              layout_with_fr(graph.obj, niter = 2000),
              layout_with_graphopt(graph.obj),
              layout_in_circle(graph.obj),
              layout_on_sphere(graph.obj),
              layout_with_sugiyama(graph.obj, layers = V(graph.obj)$node.level, hgap = 2,vgap = 2))
  
  ## ToDo: this needs work..
  if(layoutType == 5) {
    #graph.obj <- l$extd_graph
    l <- l$layout
  }
  
  if(draw.description) {
    s.title <- "Node color indicates average activation I=[-100,100] from blue to red. \n Edge width indicates strength of interaction I=[0,100]. \n Interaction strength lower 50 produces dotted lines."
  } else { 
    s.title = NULL}
  
  ## Proceed with plotation
  pdf(file = paste(f.title,".pdf",sep=""), height = 16, width = 16, useDingbats = F, onefile=TRUE)
  # plot graph and transform to ggplot-type to add legends
  plot.igraph(graph.obj, newpage=F,
              # vertex parameters
              vertex.shape=V(graph.obj)$node.shape, 
              vertex.size = scales::rescale(V(graph.obj)$size, to = c(2,7)),
              vertex.color = V(graph.obj)$node.color, vertex.frame.color = "black",
              vertex.label.cex=0.75, vertex.label.dist = 0.5, vertex.label.color = "black",
              vertex.label.family = "Times", vertex.label.font = 1,
              #vertex.label = V(graph.obj)$node.level,
              # edge parameters
              edge.lty = E(graph.obj)$edge.type,
              edge.color=E(graph.obj)$edge.color,
              edge.arrow.size=E(graph.obj)$edge.width / 5, #.99,
              edge.curved=.2,
              edge.width=E(graph.obj)$edge.width, #scales::rescale(E(graph.obj)$Weight, to = c(1,4)), #E(graph.obj)$edge.width, center=F,
              # Nope
              #edge.label = E(graph.obj)$edge.label,
              #edge.label.cex=0.25, edge.label.dist = 0.5, edge.label.color = "black",
              # grouping and layout
              main = "CARNIVAL TF-network", sub = s.title,
              mark.shape=1, mark.expand=10, #mark.groups = list(V(graph.obj)$name[V(graph.obj)$node.level == 1]),
              layout = l)
  if(draw.legend) {
    legend("topleft", 
         #title = "Node types and status",
         legend=c("TF","Perturbed","Protein","activation","inactivation"), 
         box.col="transparent", pch=c(1,0,16,NA,NA), 
         col = c("black", "black", "black","black","black"),
         cex=1, bty="n",
         #horiz=TRUE,
         #xpd=TRUE, inset=c(0, -.15), cex=.8,
         ncol=1)
    par(font = 5) #change font to get arrows
    legend("topleft", 
         legend = c(NA,NA,NA,NA,NA), pch = c(NA,NA,NA, 174, 174),
         #lwd = 1, 
         #lty = c(1,1,1,NA,NA),
         col = c(NA, NA, NA,"#AEC7E8","#FF9896"),
         cex=1, bty="n",
         ncol=1)
    par(font = 1) #back to default
  }
  # and stop plotation
  dev.off()
  
}

# Code for hypergeometric test
GSE_analysis <- function(geneList,Annotation_DB){
  
  geneList = geneList[geneList %in% unique(unlist(Annotation_DB))]
  
  ResultsDF = matrix(0,nrow = length(Annotation_DB),ncol = 5)
  rownames(ResultsDF) = names(Annotation_DB)
  colnames(ResultsDF) = c("GenesInPathway","GenesInList","GeneNames","p_value","corr_p_value")
  
  DB_genecontent = length(unique(unlist(Annotation_DB)))
  
  GenesDB = DB_genecontent 
  SelectedGenes = length(geneList)
  
  for(gset in rownames(ResultsDF)){
    GP = length(Annotation_DB[[gset]])
    GL = length(intersect(Annotation_DB[[gset]],geneList))
    
    ResultsDF[gset,"GenesInList"] = GL
    ResultsDF[gset,"GenesInPathway"] = GP
    ResultsDF[gset,"GeneNames"] = paste(intersect(Annotation_DB[[gset]],geneList),collapse = ",")
    #ResultsDF[gset,"p_value"] = HypergeometricTest(overRepres = TRUE,N = N,K = K,n = n,k = k)
    ResultsDF[gset,"p_value"] = phyper(q=GL - 1, m=GP, n=GenesDB-GP, 
                                       k=SelectedGenes, lower.tail = FALSE, log.p = FALSE)
  }
  
  ResultsDF[,"corr_p_value"] = p.adjust(ResultsDF[,"p_value"],method = "BH")
  ResultsDF = data.frame(ResultsDF,stringsAsFactors = F)
  ResultsDF = ResultsDF[order(ResultsDF[,"p_value"]),]
  
  return(ResultsDF)
  
}

## 'plotGSE' plot significantly enriched pathways
#'@param input.obj, unformatted CARNIVAL output
#'@param p.select, either "p_value" or "corr_p_value"
#'@param p.threshold, determines which pathways to include
plotGSE <- function(input.obj, p.title = "", p.select = "corr_p_value", p.threshold = 0.05) {
  
  res.plot <- input.obj %>% 
    tibble::rownames_to_column(var = "set") %>% 
    tibble %>% 
    dplyr::mutate( corr_p_value = as.numeric(corr_p_value) ) %>% 
    plyr::mutate( p_value = as.numeric(p_value) ) %>% 
    #dplyr::arrange( dplyr::desc(abs(corr_p_value)) ) %>% 
    dplyr::mutate( set = gsub(pattern = "REACTOME_", "", set)) %>% 
    dplyr::mutate( set = gsub(pattern = "_", " ", set)) %>% 
    dplyr::mutate( set = stringr::str_trunc( set, 40 ) ) %>% 
    dplyr::filter( get(p.select) < p.threshold ) %>% 
    dplyr::mutate( y.value = -log10(get(p.select)) ) %>% 
    #head(25) %>% 
    #dplyr::mutate( set = substr(set, 1, 40)) %>% 
    ggpubr::ggdotchart(., x = "set", y = "y.value", xlab = "", ylab = paste("-log10(",p.select,")", sep=""),
                       dot.size = 4, title = eval(p.title),
                       add.params = list(color = "lightgray", size = 2),
                       add = "segments",
                       rotate = TRUE
    ) + theme(axis.text=element_text(size=8), 
              legend.position = "none",
              axis.text.x = element_text(size = 12),
              axis.title=element_text(size=14,face="bold")) 
  
  return(res.plot)
}

# PROGENy - 1. STEP: Computation ------------------------------------------
# First we load our Expression data set and the results of the differential expression
# analysis. In this case we are working with output from DESeq2, but this script can
# be adjusted to work with most DEA frameworks.
Normalised_counts_matrix <- readRDS(file="data/RDS/Thyroid_normalized_counts.rds", refhook = NULL)
cova <- readRDS(file="data/RDS/Thyroid_covariates.rds", refhook = NULL)
result <- readRDS(file="data/RDS/Thyroid_result.rds", refhook = NULL)

# Pathway activities can be computed sample-wise on normalized counts or for the
# t-statistic of the case/control comparison. To that end we need to calculate t - 
# which is the ratio of fold change to its standard error.
deseq_t <- as.matrix(data.frame(row.names=rownames(result), t=result$log2FoldChange / result$lfcSE))

# We are already prepared to execute PROGENy on our count data with the Human organism data set.
PathwayActivity_counts <- progeny::progeny(Normalised_counts_matrix, scale=TRUE, 
                                           organism="Human", top = 100)
## Progeny somehow messes up the PW-naming - we will fix that now.
colnames(PathwayActivity_counts) <- gsub("-",".",colnames(PathwayActivity_counts))

PathwayActivity_stats <- progeny::progeny(deseq_t, 
                          scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = FALSE) %>%
  t ()

colnames(PathwayActivity_stats) <- "t"

## As a result we obtain the  matrix'PathwayActivity_counts' that contains sample-wise PW-activity 
# scores. We will now use limma to fit a linear model on the basis of the study design. This facilitates
# two things: 
# 1. The statistical model helps us in the evaluation of each pathways significance.
# 2. The moderated t-statistc can be used as input for the final computation in CARNIVAL.

## To execute the limma steps we transpose our output and change sample names (the latter step is optional)
PathwayActivity_counts <- t(PathwayActivity_counts)
colnames(PathwayActivity_counts) <- c("early_1","early_2","early_3","late_1","late_2","late_3")
# Now we create the design matrix that allows us to perform comparisons.
design <- model.matrix(~ 0+factor(c(rep(1,3),rep(2,3))))
colnames(design) <- c("early","late")             
# Here we specify which comparison we want to make
# In this case we take 'early' as reference level, because that's the direction in which
# we calculated the differential expression. To that end we use the column names of out design
# and say that it is 'late-stage' minus 'early-stage'
contrast.matrix <- makeContrasts(late-early, levels=design)
# Now we fit the linear model.
fit.PPA  <- lmFit(as.matrix(PathwayActivity_counts), design)
# Compute results for our chosen comparison.
fit.PPA.contrast <- contrasts.fit(fit.PPA, contrast.matrix)
# And calculate Empirical Bayes Statistics for this computation.
fit.PPA.contrast <- eBayes(fit.PPA.contrast)
# Extract the top ranked pathways and perform multiple testing correction - this gives us the t-statistic
# We are not using a p.value cutoff (p.value=1) because we want toretain all the information at this point.
res.progeny <- topTable(fit.PPA.contrast, adjust="BH",number=Inf,sort.by="t",p.value=1) 

# We can also use 'decideTests' to the direction of expression of the Pathways.
res.progeny.direction <- decideTests(fit.PPA.contrast, p.value=0.1)
# And summary gives us a qick look at the outcome.
summary(res.progeny.direction)

# The TF activity enrichment results provided by Viper are used as an input in the 
# CARNIVAL method. CARNIVAL tries to infer the most likely upstream signaling events 
# leading to the current TF activity results.
## We save the results for later use, before continuing with the analysis
# For this we put together all computed outputs.
resList.progeny <- list()
resList.progeny[["counts"]] <- PathwayActivity_counts
resList.progeny[["stats"]] <- PathwayActivity_stats
resList.progeny[["results"]] <- res.progeny
saveRDS(resList.progeny, file="data/RDS/PathwayActivity_results.rds", compress = TRUE)

## And put it in our final table
myres_list[["PW counts"]] <- PathwayActivity_counts
myres_list[["PW t-statistic"]] <- PathwayActivity_stats
myres_list[["PW results"]] <- res.progeny

# PROGENy - 2. STEP: Visualization & Investigation ------------------------
# As the input for CARNIVAL goes we are done with PROGENy. Naturally, we can investigate
# these results a little further. A first step is to create a heatmap of calculated Pathway
# activity scores per sample to check it for conspicuous clustering.

## pHEATMAP
# rotate the matrix to facilitate usage in pheatmap
plot.df <- PathwayActivity_counts
# how much nuance is the colormap supposed to have
col_cnt <- 10
#myColor <- colorRampPalette(c("darkblue", "whitesmoke","indianred"))(col_cnt)
mat_breaks <- quantile_breaks(seq(min(plot.df), max(plot.df), length.out = col_cnt), n = col_cnt + 1)

# produce the plot and put into the variable 'complete'
PW.heat <- pheatmap::pheatmap(plot.df, color = viridis::inferno(length(mat_breaks) - 1),
                               breaks = mat_breaks, scale = "none",
                               cluster_rows = T, clustering_distance_rows = "correlation",
                               cluster_cols = F,
                               fontsize_row = 10, fontsize_col = 10,
                               treeheight_col = 0,  border_color = NA,
                               main = "PROGENy (100)")
# save to pdf-file
pdf(file=paste("data/output/HeatMap.Progeny.pdf",sep=""), width=6, height=12, onefile=T)
print(PW.heat)
dev.off()

# Because we already fitted a model and calculated fold-changes and p-values, we can now
# plot those statistics for the pathway activity as well. We could for example use a barplot
# to display the fold-change or t-statistic.

## BARPLOT pathway activity
PathwayActivity_zscore_df <- as.data.frame(res.progeny) %>% 
  dplyr::rename(NES = "t") %>%
  rownames_to_column(var = "Pathway") %>%
  dplyr::arrange(logFC) %>%
  dplyr::mutate(Pathway = factor(Pathway))

pdf(file=paste("data/output/BarPlot.Progeny.PWactivity.statistic.pdf",sep=""), width=6, height=6, onefile=T)
ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, logFC), y = logFC)) + 
  geom_bar(aes(fill = NES), stat = "identity") +
  scale_fill_gradient2(low = cols[1], high = cols[3], 
                       mid = "whitesmoke", midpoint = 0) + 
  theme_minimal() +
  theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
          element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  xlab("Pathways")
dev.off()


# Dorothea - 1. STEP: Computation -----------------------------------------
# The package Dorothea calculates activity scores for Transcription Factors (TF) based 
# on expression data. To be precise, the package provides a Wrapper for 'Viper' which 
# actually does the work. So we will now compute TF activity scores based on the normalized
# counts. Subsequently employ limma to fit a linear model and perform statistic analyses.
# This provides us with the means to further evaluate the output of Dorothea, as well as
# with input for the CARNIVAL analysis step.

# First we load our Expression data set and the results of the differential expression
# analysis. In this case we are working with output from DESeq2, but this script can
# be adjusted to work with most DEA frameworks.
Normalised_counts_matrix <- readRDS(file="data/RDS/Thyroid_normalized_counts.rds", refhook = NULL)
cova <- readRDS(file="data/RDS/Thyroid_covariates.rds", refhook = NULL)
result <- readRDS(file="data/RDS/Thyroid_result.rds", refhook = NULL)

# Transcription Factor activities can be computed sample-wise on normalized counts or 
# for the t-statistic of the case/control comparison. To that end we need to calculate 
# t - which is the ratio of fold change to its standard error.
deseq_t <- as.matrix(data.frame(row.names=rownames(result), t=result$log2FoldChange / result$lfcSE))

# We estimate the transcription factor (TF) activity using the DoRothEA R package. 
# We select interactions with confidence level A, B and C.
## We load Dorothea Regulons
data(dorothea_hs, package = "dorothea")
regulons <- dorothea_hs %>%
  dplyr::filter(confidence %in% c("A", "B","C"))

# Execute dorotheas 'run_viper' on t-statistic to calculate overall TF-activity scores
TFActivity_stat <- dorothea::run_viper(deseq_t, regulons,
                                          options =  list(minsize = 15, eset.filter = FALSE, 
                                                          cores = 1, verbose = FALSE, nes = TRUE))

# Execute dorotheas 'run_viper' to calculate sample-wise TF-activity scores
TFActivity_counts <- 
  dorothea::run_viper(Normalised_counts_matrix, regulons,
                      options =  list(minsize = 15, eset.filter = FALSE, 
                                      cores = 1, verbose = FALSE, method = c("scale")))

## 'TFActivity_counts' contains sample-wise TF-activity scores and we require a single input value
# for the TF-activites - so now we will use limma to fit a linear model and calculate the t-statistic
# somehow
colnames(TFActivity_counts) <- c("early_1","early_2","early_3","late_1","late_2","late_3")
# construct our design to facilitate comparisons
design <- model.matrix(~ 0+factor(c(rep(1,3),rep(2,3))))
colnames(design) <- c("early","late")             
# here we specify which comparison we want to make
# In this case we take 'early' as reference level, because that's the direction in which
# we calculated the differential expression. To that end we use the column names of out design
# and say that it is 'late-stage' minus 'early-stage'
contrast.matrix <- makeContrasts(late-early, levels=design)
# fit the linear model 
fit.DTA  <- lmFit(as.matrix(TFActivity_counts), design)
# and get results for our chosen contrast
fit.DTA.contrast <- contrasts.fit(fit.DTA, contrast.matrix)
# calculate Empirical Bayes Statistics for Differential Expression
fit.DTA.contrast <- eBayes(fit.DTA.contrast)
# extract the top ranked pathways and perform multiple testing correction - this gives us the t-statistic
res.dorothea <- topTable(fit.DTA.contrast, adjust="BH",number=Inf,sort.by="t",p.value=1) # keep p.cutoff at one because we want to keep everything

# We can also use 'decideTests' to the direction of expression of the Pathways.
res.dorothea.direction <- decideTests(fit.DTA.contrast, p.value=0.1)
# And summary gives us a qick look at the outcome.
summary(res.dorothea.direction)

# The TF activity enrichment results provided by Viper are used as an input in the 
# CARNIVAL method. CARNIVAL tries to infer the most likely upstream signaling events 
# leading to the current TF activity results.
## We save the results for later use, before continuing with the analysis

resList.dorothea <- list()
resList.dorothea[["counts"]] <- TFActivity_counts
resList.dorothea[["stats"]] <- TFActivity_stat
resList.dorothea[["results"]] <- res.dorothea
saveRDS(resList.dorothea, file="data/RDS/TFActivity_CARNIVAL_results.rds", compress = TRUE)

## And put it in our final table
myres_list[["TF counts"]] <- TFActivity_counts
myres_list[["TF t-statistic"]] <- TFActivity_stat
myres_list[["TF results"]] <- res.dorothea

# Dorothea - 2. STEP: Visualization & Investigation -----------------------
# As the input for CARNIVAL goes we are done with Dorothea. Naturally, we can investigate
# these results a little further. A first step is to create a heatmap of calculated TF
# activity scores per sample to check it for conspicuous clustering.

# We use the computed statistics to limit the selection to TFs with significant pvalues.
TF_activity <- rownames(res.dorothea[res.dorothea$P.Value <= 0.05,])
# And create our plot-data-frame.
plot.df <- TFActivity_counts %>%
  as.data.frame() %>% 
  dplyr::filter(rownames(TFActivity_counts) %in% TF_activity)

# how much nuance is the colormap supposed to have
col_cnt <- 10
mat_breaks <- quantile_breaks(seq(min(plot.df), max(plot.df), length.out = col_cnt), n = col_cnt + 1)

# produce the plot and put into the variable 'complete'
TF.heat <- pheatmap::pheatmap(plot.df, color = viridis::inferno(length(mat_breaks) - 1),
                               breaks = mat_breaks, scale = "none",
                               cluster_rows = T, clustering_distance_rows = "correlation",
                               cluster_cols = F,
                               fontsize_row = 5, fontsize_col = 12,
                               main = "Thyroid cancer - TF-activity scores",
                               subtitle = 'significant TFs - p <= 0.05')

# save to pdf-file
pdf(file=paste("data/output/HeatMap.Thyroid.TF.activity.scores.pdf",sep=""), width=6, height=12, onefile=T)
print(TF.heat)
dev.off()


# And we create a bar-plot of fold-change or NES (normalized enrichment scores; t-statistic)
# for significant TFs.
tf_activities_stat <- res.dorothea %>%
  as.data.frame() %>% 
  rownames_to_column(var = "GeneID") %>%
  dplyr::rename(NES = "t") %>%
  dplyr::filter(P.Value < 0.05) %>%
  dplyr::arrange(NES) %>% 
  dplyr::mutate(GeneID = factor(GeneID))

TF.scores <- ggplot(tf_activities_stat,aes(x = reorder(GeneID, logFC), y = logFC)) + 
  geom_bar(aes(fill = logFC), stat = "identity") +
  scale_fill_gradient2(low = cols[1], high = cols[3], 
                       mid = "whitesmoke", midpoint = 0) + 
  theme_minimal() +
  theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
          element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  xlab("Transcription Factors")

pdf(file=paste("data/output/Barplot.Thyroid.TF.NES.significant.pdf",sep=""), width=6, height=12, onefile=T)
print(TF.scores)
dev.off()

# To interpret the results, we can look at the expression of targets of one of the 
# most deregulated TFs, such as MYC. To that end we select all the genes that are
# associated with the MYC transcription factor and display their DEA results in a
# volcano plot. Another idea would be to produce a heatmap of expression values for
# all samples in the set - but to that end some more filtering is required, as the 
# number of genes affected by any one TF can be quite large.
targets_MYC <- regulons$target[regulons$tf == "MYC"]
# subset for chosen targets to create our plotting data.frame
plot.df <- result %>%
  as.data.frame() %>% 
  rownames_to_column(var = "GeneID") %>%
  dplyr::filter(GeneID %in% targets_MYC)

# Visualize the expresssion of associated genes in a volcano plot
vp_dorothea <- EnhancedVolcano::EnhancedVolcano(plot.df,                   # our data
                                                lab = plot.df$GeneID,   # how to name the dots later on
                                                x = 'log2FoldChange',     # where do we find the log fold column
                                                y = 'pvalue',             # where the p-value
                                                xlim = c(-4, 4),          # plot from where to where on the x axis
                                                ylim = c(0, 8),           # and on the y axis
                                                legendPosition = 'bottom', # where to put the legend
                                                pCutoff = 0.05,          # what do we consider significant (p-value)
                                                FCcutoff = .5,             # what do we consider significant (fold change)     
                                                pointSize = 1.0,          # Some other parameters
                                                drawConnectors = TRUE,
                                                widthConnectors = 0.2,
                                                colConnectors = 'grey30',
                                                title = 'Dorothea - TF:', # plot title
                                                subtitle = 'MYC target gene expression',
                                                xlab = "logFC") # how to name the x axis

pdf(file=paste("data/output/Volcano.Thyroid.TF.MYC.target.expression.pdf",sep=""), width=6, height=12, onefile=T)
print(vp_dorothea)
dev.off()

## This concludes all the steps to facilitate the execution of CARNIVAL, but the output
# of PROGENy and Dorothea could be investigated in more detail!

# CARNIVAL - STEP 1: Omnipath scaffold ------------------------------------
## CARNIVAL is an approach that works on networks which represent the interactions
# between genes. In this step we will retrieve one of such networks from Omnipath
# to use it as a basis for the execution of CARNIVAL.
AllInteractions = OmnipathR::import_Omnipath_Interactions(select_organism = 9606) 

## We transform to the format needed by CARNIVAL. We just keep signed and 
## directed interactions 
SignedDirectedInteractions <- filter(AllInteractions, is_directed == 1) %>%
  filter(is_stimulation == 1 | is_inhibition == 1)

InputCarnival <- bind_rows(
  (SignedDirectedInteractions %>%
     filter(is_stimulation == 1 & is_inhibition == 0) %>%
     transmute(source_genesymbol, interaction = 1, target_genesymbol)),   
  (SignedDirectedInteractions %>%
     filter(is_stimulation == 0 & is_inhibition == 1) %>%
     transmute(source_genesymbol, interaction = -1, target_genesymbol))) %>%  
  distinct() 

## We have to be careful with the gene names with a "-". CPLEX gets crazy. 
InputCarnival$source_genesymbol <- 
  gsub("-","_",InputCarnival$source_genesymbol)
InputCarnival$target_genesymbol <- 
  gsub("-","_",InputCarnival$target_genesymbol)

bad_int <- which(duplicated(paste(InputCarnival[,1],InputCarnival[,3])))

if ( length(bad_int) == 0 ) {
  InputCarnival <- InputCarnival
} else {
  InputCarnival = InputCarnival[-bad_int,]
}

# This network only changes if the underlying database has been updated. To facilite a
# faster workflow and have a fallback in case of problems with the internet connection,
# we will save the finished network-object.
saveRDS(InputCarnival, file="data/RDS/CARNIVAL.network.rds", compress = TRUE)


# CARNIVAL - STEP 2: prepare PD-input -------------------------------------
# In addition to the interaction network, we need actual study related input.
# The transcription factor activity computed with dorothea is a required input for CARNIVAl.
# The PW activity scores of PROGENy are an optional input- that we will happily provide here.
# 1. Dorothea output
TFActivity_results <- readRDS(file="data/RDS/TFActivity_CARNIVAL_results.rds", refhook = NULL)
# 2. OPTIONAL Progeny output
PathwayActivity_results <- readRDS(file="data/RDS/PathwayActivity_results.rds", refhook = NULL)

## the data requires some adjustment to work with CARNIVAL, we need vectors with gene names 
# and relevant scores
# starting with the pathway activity scores in the progeny output
PathwayActivity_CARNIVALinput <- PathwayActivity_results$stats %>%
  as.data.frame() %>%
  dplyr::rename(score = "t") %>%
  rownames_to_column(var = "Pathway")
  
# load progeny pathways and associated genes/proteins and respective identifiers
load(file = system.file("progenyMembers.RData",package="CARNIVAL"))
# we only require the gene names 
progenyMembers <- progenyMembers$gene
# most pathways have multiple associated genes - we want a vector that contains all the genes and
# the score of their respective pathway
# So we transform the 'progenyMembers' list into a data.frame where the genes are comma separated
# use separate_rows() to split up the commas and insert new rows
# use left_join() to insert the calculated scores we loaded earlier
tmp <- data.frame(dplyr::left_join(
  tidyr::separate_rows(
    data.frame(row.names = NULL,
               Pathway= names(progenyMembers), 
               genes=sapply(progenyMembers, function(pw) paste(pw,collapse = ",")), 
               stringsAsFactors = F), 
    genes, sep=","), 
  PathwayActivity_CARNIVALinput, by="Pathway"),stringsAsFactors = F)
# Then just extract the scores and add gene name to each element =)
progenyScores <- data.frame(t(sort(tmp[,"score"])))
#rownames(progenyScores) = "NES"
colnames(progenyScores) = tmp$genes


# Now we will do something similar with the TF-scores we calculated in Dorothea
# This is much easier - we just need to select our top 25,50,100,.. genes
## sorting by absolute value
TFActivity_CARNIVALinput <- TFActivity_results$results %>%
  as.data.frame() %>% 
  rownames_to_column(var = "TF") %>%
  dplyr::filter(P.Value < 1.05)

# And select the TopXX scores from the 't' column - also transpose because apparently CARNIVAL has the shittiest code ever..
dorotheaScores <- data.frame(t(sort(TFActivity_CARNIVALinput[,"t"])))
  rownames(dorotheaScores) = "NES"
  colnames(dorotheaScores) = TFActivity_CARNIVALinput$TF



# CARNIVAL - STEP 3: Run the Algorithm ------------------------------------
InputCarnival <- readRDS(file="data/RDS/CARNIVAL.network.rds", refhook = NULL)

# get initial nodes - I'm not quite sure what this is supposed to do, because the code produces
# an empty named vector?!
iniMTX = base::setdiff(InputCarnival$source_genesymbol, InputCarnival$target_genesymbol)
iniciators = base::data.frame(base::matrix(data = NaN, nrow = 1, ncol = length(iniMTX)), stringsAsFactors = F)
colnames(iniciators) = iniMTX


# We produced all the input required to run CARNIVAL - depending on the complexity of the
# task at hand this can take quite some time.
carnival_result = runCARNIVAL( inputObj= iniciators,
                               measObj = dorotheaScores,        # dorothea output
                               netObj = InputCarnival,          # Network of interacting genes
                               weightObj = progenyScores,       # (OPTIONAL) progeny output
                               solverPath = "/Applications/CPLEX_Studio1210/cplex/bin/x86-64_osx/cplex", 
                               solver = "cplex",
                               timelimit=10000,                   # if no solution can be found, enlarge this value
                               dir_name = paste(WORKDIR,"data/output", sep="/"),              # path to the output directory
                               mipGAP=0,
                               poolrelGAP=0 )
# And as always we will save our results
saveRDS(carnival_result, file="data/RDS/CARNIVAL_results_late_vs_early_v2.rds", compress = TRUE)

# Also save it to file for later inspection
write.table(carnival_result$weightedSIF,col.names = T,row.names = F,
            sep = ",", file = "CARNIVAL_results_late_vs_early_network.csv", quote = F)
write.table(carnival_result$nodesAttributes,col.names = T,row.names = F,
            sep = ",", file = "CARNIVAL_results_late_vs_early_nodes.csv", quote = F)


# This concludes the mostly computational steps in the Progeny, Dorothea, Carnival (PDC) pipeline.
# Next we will continue with the investigation and visualization of our results.



# CARNIVAL - STEP 4: Visualization & Investigation ------------------------
carnival_result <- readRDS(file="data/RDS/CARNIVAL_results_late_vs_early.rds", refhook = NULL)

## Here we extract the network topology from CARNIVAL's output, i.e., this is a list of 
# node pairs (Node1, Node2) connected by directed edges that have a weight attribute (Weight) as
# well as an indication for the type of relationship (Sign), i.e., activation (1) or inhibition (-1).
### Display the inferred transcription factor activity in a network.
# Parameter 'weightCut' removes edges, i.e., transcription factor activities lower than the chosen
# threshold I=[0,100].
# Parameter 'clusterSize' only allows clusters with size equal or bigger than threshold.
carnival.net <- networkCARNIVAL(carnival_result, weightCut = 0, clusterSize = 15)

# And plot the network. The plot is exported to pdf Format.
plotCnet(carnival.net, layoutType=1, f.title="data/output/CARNIVAL_C15",draw.legend=TRUE, draw.description=TRUE)

### Now we will investigate the activity of TFs in a functional context with gene set enrichment
# analysis.

## Here we retrieve the attributes of all nodes in the network, i.e., node type, activation status.
nodes <- data.frame(carnival_result$nodesAttributes,
                    stringsAsFactors = F) %>% 
  mutate(act_sign = sign(as.numeric(AvgAct)))

# Are active nodes enriched for a function?
# Extract the active nodes and perform gene-set enrichment (GSE) to determine significantly enriched pathways.
active_nodes = nodes %>% filter(act_sign == 1)
# GSE and Hypergeometric test for the active nodes.
gse_active <- GSE_analysis(geneList = active_nodes[[1]],
                           Annotation_DB = onco_gsets)

## Are inactive nodes enriched for a function?
# Extract the inactive nodes and perform gene-set enrichment (GSE) to determine significantly enriched pathways.
inactive_nodes = nodes %>% filter(act_sign == -1)
# GSE and Hypergeometric test for the inactive nodes.
gse_inactive <- GSE_analysis(geneList = inactive_nodes[[1]],
                             Annotation_DB = onco_gsets)

## Set variables with type of p-value and threshold for significance.
p.select <- "p_value"
p.threshold <- 0.05
# And have a look, i.e., how many significant gene sets remain with these parameters.
gse_active %>% dplyr::filter( get(p.select) < p.threshold ) %>% nrow
gse_inactive %>% dplyr::filter( get(p.select) < p.threshold ) %>% nrow

## After we have chosen the correct values we will visualize the most significant pathways.
p.active <- plotGSE(gse_active, p.title = "Active nodes ", p.select, p.threshold)
p.inactive <- plotGSE(gse_inactive, p.title = "Inactive nodes", p.select, p.threshold)
# And write to file
pdf(file = "data/output/CARNIVAL_TF_OncogenicGeneSets_late_vs_early.pdf", height = 18, width = 18, useDingbats = F, onefile=TRUE)
p.active | p.inactive
dev.off()

# We extract our TF (Dorothea) results to take a look at the distribution of active and inactive nodes.
TF.stats <- TFActivity_results$results %>%
  rownames_to_column(var = "Gene")
  
# Are active nodes upregulated?
useful_nodes <- nodes %>% filter(act_sign != 0) %>%
  left_join(TF.stats, by = c("Node"="Gene"))

# prepare Violin plot with statistical test on active/inactive nodes distribution.
p.nodes <- ggpubr::ggviolin(useful_nodes, x="act_sign", y = "logFC", fill = "act_sign",
                            alpha = 0.75,
                            palette = c("#D62728", "#7F7F7F"),
                            add = c("jitter", "boxplot"),
                            add.params = list(fill = "white"),
                            trim = T,
                            title	= "Dorothea activation status",
                            subtitle = "Thyroid Late vs Early",
                            xlab = "Activation direction",
                            ylab = "log2 FoldChange") +
  ggpubr::stat_compare_means() +
  theme_bw()
# Move the plots legend to the bottom for a ncer plot.
p.nodes <- ggpubr::ggpar(p.nodes, legend="bottom")

# Only save this plot to file.
pdf(file = "data/output/CARNIVAL_TF_regulation_late_vs_early.pdf.pdf", height = 6, width = 6, useDingbats = F, onefile=TRUE)
p.nodes
dev.off()

# Save all plots to file
pdf(file = "data/output/CARNIVAL_TF_regulation_OncoGeneSets_late_vs_early.pdf.pdf", height = 6, width = 6, useDingbats = F, onefile=TRUE)
ggpubr::ggarrange(p.nodes,ggpubr::ggarrange(p.active, p.inactive, nrow=2))
dev.off()

summary( lm(logFC ~ factor(act_sign), data = useful_nodes) )

## And export results to table format.
myres_list[["ONCO activated Late vs Early"]] <- gse_active
myres_list[["ONCO in-activated Late vs Early"]] <- gse_inactive

## And finally export all the results in an excel table.
openxlsx::write.xlsx(myres_list,file = paste("data/output/Thyroid.PDC.LATEvsEARLY.xlsx",sep=""),
                     rowNames=TRUE,colNames=TRUE, colWidths = c(NA, "auto", "auto"))



















